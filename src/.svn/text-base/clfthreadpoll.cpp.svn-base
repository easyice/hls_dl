/*
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2012  elva <email>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#include "clfthreadpoll.h"
#include "chttpserver.h"
#include "ceventhandle.h"
#include <iostream>
#include <sys/types.h>

#include <stdio.h>



using namespace std;





CLFThreadPoll::CLFThreadPoll(CHttpServer* s)
{
	m_pHttpServer = s;
	
	m_nMaxThreads = 10;
	m_pThreadid = NULL;
}

CLFThreadPoll::~CLFThreadPoll()
{

}

void CLFThreadPoll::SetMaxThreads(int maxThreads)
{
	m_nMaxThreads = maxThreads;
}

void* CLFThreadPoll::WorkThread(void* pParam)
{
	THREAD_PARAM_T *pThParam = (THREAD_PARAM_T*) pParam;
	CLFThreadPoll* lpthis = (CLFThreadPoll*) pThParam->lpThis;
	lpthis->WorkFun(pThParam->pEventHandle);

	return NULL;
}

void CLFThreadPoll::WorkFun(CEventHandle* pEventHandle)
{
	epoll_event epEv;
	while(1)
	{
		WaitToLeader();
		
		epEv = m_pHttpServer->WaitForOneEvent();
		
		PromoteNewLeader();
		
		pEventHandle->ProcessEvent(epEv);
	}
}

inline void CLFThreadPoll::WaitToLeader()
{
	pthread_mutex_lock( &m_mutexWork );
}


inline void CLFThreadPoll::PromoteNewLeader()
{
	pthread_mutex_unlock( &m_mutexWork );
}


void CLFThreadPoll::Start()
{
	pthread_mutex_init ( &m_mutexWork,NULL );
	
	
	
	m_pThreadid = new pthread_t[m_nMaxThreads];
	m_pThreadParam = new THREAD_PARAM_T[m_nMaxThreads];
	for (int i = 0; i < m_nMaxThreads; i++)
	{
		CEventHandle* pEh = new CEventHandle();
		m_vecEventHandler.push_back(pEh);
		
		m_pThreadParam[i].pEventHandle = pEh;
		m_pThreadParam[i].lpThis = this;
		pthread_create(&m_pThreadid[i],NULL,WorkThread,&m_pThreadParam[i]);
	}
	
	
	//PromoteNewLeader();
}

void CLFThreadPoll::Destroy()
{
	pthread_mutex_destroy ( &m_mutexWork );
	
	//pthread_kill...
	
	vector<CEventHandle*>::iterator it = m_vecEventHandler.begin();
	for (; it != m_vecEventHandler.end(); ++it)
	{
		delete (*it);
	}
	delete [] m_pThreadid;
	delete [] m_pThreadParam;
}


