/*
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2012  elva <email>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#include "csessionmgr.h"

#include <stdio.h>
#include <sys/epoll.h>
#include "cconnectionmgr.h"
#include <assert.h>

#include "define.h"


CSessionMgr* CSessionMgr::m_pStatic = NULL;



CSessionMgr::CSessionMgr()
{
	m_nMaxUser = 0;
	m_pSessionPoll = NULL;
	m_nCurUserCount = 0;
        m_nTimeOut = 60*10;
	
	pthread_mutex_init (&m_mutex,NULL);
}

CSessionMgr::~CSessionMgr()
{
	pthread_mutex_destroy (&m_mutex);
	m_mapSessionIdx.clear();
}

CSessionMgr* CSessionMgr::GetInstancePtr()
{
	if (NULL == m_pStatic)
	{
		m_pStatic = new CSessionMgr();
	}

	return m_pStatic;
}

bool CSessionMgr::Init(int maxuser)
{
	m_nMaxUser = maxuser;
		
	m_pSessionPoll = new ZSafeObjPool<SESSION_T>("SessionPoll",m_nMaxUser);

	SESSION_T** pSessionIdx = new SESSION_T*[m_nMaxUser];
	
	for (int i = 0 ; i < m_nMaxUser; i++)
	{
		SESSION_T *pSession = m_pSessionPoll->Alloc();
		assert(pSession != NULL);

		pthread_mutex_init (&pSession->mutex,NULL);
		
		pSessionIdx[i] = pSession;
	}
	for (int i = 0 ; i < m_nMaxUser; i++)
	{
		m_pSessionPoll->Release(pSessionIdx[i]);
	}
	
	delete pSessionIdx;
	
	return true;
}

void CSessionMgr::SetUserTimeOut(time_t nTimeOut)
{
        m_nTimeOut = nTimeOut;
}


SESSION_T* CSessionMgr::AllocUserSession(const string& strSessionId,bool bAllowReuse)
{
	if (strSessionId.empty())
	{
		ZLOG(ZLT_ERROR,"用户ID为空");
		return NULL;
	}
	
	SESSION_T *pSession = NULL;
	pthread_mutex_lock(&m_mutex);
	map<string,SESSION_T*>::iterator it = m_mapSessionIdx.find(strSessionId);
	if (it != m_mapSessionIdx.end())
	{
		if (!bAllowReuse && it->second->bUseing)
		{
			vs_log(LV_ERROR,"不允许并发连接,当前连接数:%d\n",CConnectionMgr::GetInstancePtr()->GetConnectionCount());
			pthread_mutex_unlock(&m_mutex);
			return NULL;
		}
		vs_log(LV_USER,"申请到已存在的会话:%s",strSessionId.c_str());
		it->second->bUseing = true;
		pthread_mutex_unlock(&m_mutex);
		return it->second;
	}
	else
	{
		pSession = m_pSessionPoll->Alloc();
	}

	if (pSession == NULL)
	{
		ZLOG(ZLT_ERROR,"用户数量已满无法为用户分配会话资源",V(strSessionId));
		pthread_mutex_unlock(&m_mutex);
		return NULL;
	}
	vs_log(LV_USER,"申请到全新的会话:%s\n",strSessionId.c_str());
	
        pSession->bUseing = true;
        pSession->bEof = false;
        pSession->nReadedGop = 0;
        pSession->updateTime = 0;
        
	m_mapSessionIdx.insert(map<string,SESSION_T*>::value_type(strSessionId,pSession));
        m_nCurUserCount++;
        pthread_mutex_unlock(&m_mutex);

	return pSession;
}

SESSION_T* CSessionMgr::FindUserSession(const string& strSessionId)
{
        if (strSessionId.empty())
        {
                ZLOG(ZLT_ERROR,"用户ID为空");
                return NULL;
        }
        
        SESSION_T *pSession = NULL;
        pthread_mutex_lock(&m_mutex);
        map<string,SESSION_T*>::iterator it = m_mapSessionIdx.find(strSessionId);
        if (it != m_mapSessionIdx.end())
        {
                pSession =  it->second;
                //pSession->bUseing = true;
        }

        pthread_mutex_unlock(&m_mutex);
        return pSession;
}


void CSessionMgr::FreeUserSession(const string& strSessionId)
{
	//remove from map
	pthread_mutex_lock(&m_mutex);
	map<string,SESSION_T*>::iterator it = m_mapSessionIdx.find(strSessionId);
	if ( it == m_mapSessionIdx.end())
	{
		pthread_mutex_unlock(&m_mutex);
		ZLOG(ZLT_ERROR,"用户不存在");
		return;
	}
	
	ClearSessionResource(it->second);
	
	m_mapSessionIdx.erase(it);

        pthread_mutex_unlock(&m_mutex);
	
}

void CSessionMgr::ClearSessionResource(SESSION_T* pSession)
{
        if (pSession->pTsReader != NULL)
        {
                pSession->pTsReader->Close();
                delete pSession->pTsReader;
                pSession->pTsReader = NULL;
        }
        
        delete pSession->pM3u8Gen;
        pSession->pM3u8Gen = NULL;
        
        pSession->bUseing = false;
        pSession->bEof = false;
        pSession->nReadedGop = 0;
        pSession->updateTime = 0;
        
        vs_log(LV_DEBUG_EV,"ClearSessionResource,tid=%d\n",gettid());
        m_pSessionPoll->Release(pSession);
        
        m_nCurUserCount--;
}

int CSessionMgr::GetUserCount()
{
	return m_nCurUserCount;
}

void CSessionMgr::CheckTimeOut()
{
        time_t curTime;
        time(&curTime);
        map<string,SESSION_T*>::iterator it;
        pthread_mutex_lock(&m_mutex);
        
        map<string,SESSION_T*>::iterator _end = m_mapSessionIdx.end();
        for (it = m_mapSessionIdx.begin(); it != _end;)
        {
                time_t oldTime = it->second->updateTime;
                if (!it->second->bUseing && curTime - oldTime > m_nTimeOut)
                {
                        ZLOG(ZLT_USER,"删除超时的用户会话",V(it->first));
                        
                        ClearSessionResource(it->second);
                        
                        m_mapSessionIdx.erase(it++);
                }
                else
                {
                        ++it;
                }                       
        } //!for
        
        pthread_mutex_unlock(&m_mutex);
}


