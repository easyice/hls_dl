/*
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2012  elva <email>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#include "crequestprocess.h"

#include "define.h"
#include "protocal.h"
#include <stdio.h>
#include "chttpcore.h"



#define RESPONSE_HTTP_HEAD 4096

extern int g_nUserWBufferSize;

void printMessage( SP_HttpMessage * message )
{
	for( int i = 0; i < message->getHeaderCount(); i++ ) {
		printf( "%s: %s\n", message->getHeaderName( i ), message->getHeaderValue( i ) );
	}
	printf( "\n" );

	if( NULL != message->getContent() ) {
		printf( "%s", (char*)message->getContent() );
	}

	printf( "\n" );
}

void printRequest( SP_HttpRequest * request )
{
	printf("request:\n");
	printf( "%s %s %s\n", request->getMethod(), request->getURI(), request->getVersion() );

	for( int i = 0; i < request->getParamCount(); i++ ) {
		printf( "Param: %s=%s\n", request->getParamName(i), request->getParamValue(i) );
	}

	printMessage( request );
}

CRequestProcess::CRequestProcess()
{
	m_pSendBuf = new BYTE[g_nUserWBufferSize];
	
	m_pHttpHead = new char[RESPONSE_HTTP_HEAD];
	
	m_pHttpCore = new CHttpCore(m_pHttpHead,RESPONSE_HTTP_HEAD,m_pSendBuf,g_nUserWBufferSize-RESPONSE_HTTP_HEAD);
}

CRequestProcess::~CRequestProcess()
{
	delete [] m_pSendBuf;
	delete [] m_pHttpHead;
	delete m_pHttpCore;
}

bool CRequestProcess::ProcessNewRequest(const char* strReq,int nLen,CONNECTION_T* pConn)
{
	/*
	 * 对处理后待发的数据，有以下处理方式：
	 * 1.对于ts数据的处理，一直到片段发送完毕或底层缓冲已满。他是分次加载到待发缓冲的
	 * 2.其他数据，都能完整的放入待发缓冲，不会分次加载
	 */
	SP_HttpMsgParser parser;
	SP_HttpRequest * request = NULL;
	parser.setIgnoreContent( 1 );
	parser.append( strReq, nLen );
	
	
	if( (request = parser.getRequest()) == NULL )
	{
                ZLOG(ZLT_ERROR,"parser.getRequest faild!");
		return false;
	}
	//printRequest( request );
	
	//过滤非法请求
	if (!CheckRequest(request))
	{
                ZLOG(ZLT_ERROR,"CheckRequest faild!");
                printRequest( request );
		return false;
	}
	
	REQ_TYPE_T reqType = GetRequestType(request);
	pConn->emReqType = reqType;
	
	vs_log(LV_DEBUG_EV,"sock=%04d,NewReq,reqType=%d",pConn->sock,pConn->emReqType);

        CHttpModBase* pHttpMod = m_pHttpCore->GetHttpModule(reqType);
        SEND_RES_T ret;
        
	//check Range
//         using namespace http;
//         for( int i = 0; i < request->getHeaderCount(); i++ )
//         {
//                 if (0 == strcasecmp(request->getHeaderName( i ),HEADER_RANGE) &&
//                         0 == strcasecmp(request->getHeaderValue( i ),"bytes=0-1"))
//                 {
//                         ret = pHttpMod->OnRequestRange01(pConn);
//                         goto process_end;
//                 }
//         }
        
	if (pConn->pSession == NULL && !CheckAllocSession(reqType,request,pConn))
        {
                ZLOG(ZLT_ERROR,"CheckAllocSession faild!");
                return false;
        }
	else
        {
                time(&pConn->pSession->updateTime);
        }
	
	//处理请求，将待发送数据放缓冲
	ret = pHttpMod->ProcessNewRequest(request,pConn);

//process_end:
	
	if (ret == RES_ERROR)
	{
		vs_log(LV_ERROR,"ProcessNewRequest 出错，关闭连接");
		return false;
	}
	if (ret == RES_ACTIVE_CLOSE)
        {
                return false;
        }
        
	return true;
}

bool CRequestProcess::CheckAllocSession(REQ_TYPE_T reqType, const SP_HttpRequest* request, CONNECTION_T* pConn)
{
        
        
        if (reqType == REQ_TYPE_M3U8 ) //允许多 socet 可重用 session
        {
                if (!AllocSession(request,pConn,true))
                {
                        vs_log(LV_ERROR,"申请会话失败");
                        return false;
                }
        }
        else if (reqType == REQ_TYPE_CTL ||
                reqType == REQ_TYPE_TS) //仅获取现有 session  不申请新的
        {
                if (!GetSession(request,pConn))
                {
                        vs_log(LV_ERROR,"获取会话失败");
                        return false;
                }
                //避免并发的请求ts
                if (reqType == REQ_TYPE_TS && pConn->pSession->bUseing)
                {
                        vs_log(LV_ERROR,"不允许并发请求TS");
                        return false;
                }
                pConn->pSession->bUseing = true;
        }
        else if (reqType == REQ_TYPE_TEST_VIDEO)     //不可重用session
        {
                if (!AllocSession(request,pConn,false))
                {
                        return false;
                }
        }
        return true;
}

bool CRequestProcess::ProcessContinue(CONNECTION_T* pConn)
{
	if (pConn->pStatus->GetStatus() == ST_READY)
	{
		vs_log(LV_WARNING,"sock=%04d,nothing to do",pConn->sock);
		return true;
	}

	CHttpModBase* pHttpMod = m_pHttpCore->GetHttpModule(pConn->emReqType);
		
	//先将用户缓冲剩余数据发送完毕或直到底层缓冲满
	SEND_RES_T emRet = pHttpMod->SendBufferedData(pConn);
	
	if (emRet == RES_ERROR)
	{
		return false;
	}
	else if (emRet == RES_AGAIN)
	{
		return true;
	}
	
	if (pConn->emReqType == REQ_TYPE_TEST_PAGE)
        {
                return false; //close conn
        }
	
	//只为测试视频与 TS请求处理
	if (pConn->emReqType != REQ_TYPE_TEST_VIDEO &&
                pConn->emReqType != REQ_TYPE_TS)
        {
                //ZLOG(ZLT_ERROR,"错误的请求类型",V(pSession->emReqType),V(pSession->sock));
                vs_log(LV_ERROR,"错误的请求类型,%d",pConn->emReqType );
                return false;
        }

	emRet = pHttpMod->ProcessContinue(pConn);
        
        if (emRet != RES_SUCCESS && pConn->pWriteBuffer->GetDataLen() == 0)
        {
                ZLOG(ZLT_USER,"之前没有考虑到的");
                pConn->pStatus->SetStatus(ST_READY);
        }
        
	if (emRet == RES_SUCCESS)
	{
		vs_log(LV_USER,"sock=%04d,请求处理完毕!!!",pConn->sock);
                pConn->pStatus->SetStatus(ST_READY);
	}
	else if (emRet == RES_ERROR)
	{
		return false;
	}
	
        
	return true;
}

bool CRequestProcess::CheckRequest(const SP_HttpRequest* request)
{
	using namespace http;
	
	const char* methon = request->getMethod();
	if( 0 == strncasecmp( methon, known_http_methods[HTTP_GET].ptr,
		known_http_methods[HTTP_GET].len) )
	{
		return true;
	}
	
	return false;
}


REQ_TYPE_T CRequestProcess::GetRequestType(const SP_HttpRequest * request)
{
	using namespace vs_protocal;
	
	const char* uri = request->getURI();
	
	if( 0 == strcasecmp( uri, URI_M3U8 ) )
	{
		return REQ_TYPE_M3U8;
	}
	else if( 0 == strcasecmp( uri, URI_GETTS ) )
        {
                return REQ_TYPE_TS;
        }
        else if( 0 == strcasecmp( uri, URI_SWITCH ) )
        {
                return REQ_TYPE_CTL;
        }
        else if( 0 == strcasecmp( uri, URI_SEEK ) )
        {
                return REQ_TYPE_CTL;
        }
	else if( 0 == strncasecmp( uri, URI_TEST_VIDEO, strlen(URI_TEST_VIDEO)) )
	{
		return REQ_TYPE_TEST_VIDEO;
	}
	
	
	return REQ_TYPE_TEST_PAGE;
}

bool CRequestProcess::AllocSession(const SP_HttpRequest* request, CONNECTION_T* pConn,bool bAllowReuse)
{
	using namespace vs_protocal;
	
	const char* session_id = NULL;
	for( int i = 0; i < request->getParamCount(); i++ )
	{
		if( 0 == strcasecmp( request->getParamName(i), PARAM_SESSIONID ) )
		{
			session_id = request->getParamValue(i);
			break;
		}
	}
	
	if (session_id == NULL)
	{
		ZLOG(ZLT_ERROR,"参数缺少SessionID");
		return false;
	}
	
	pConn->pSession = CSessionMgr::GetInstancePtr()->AllocUserSession(session_id,bAllowReuse);
	
	if (pConn->pSession == NULL)
	{
		return false;
	}

	return true;
}


bool CRequestProcess::GetSession(const SP_HttpRequest* request, CONNECTION_T* pConn)
{
        using namespace vs_protocal;
        
        const char* session_id = NULL;
        for( int i = 0; i < request->getParamCount(); i++ )
        {
                if( 0 == strcasecmp( request->getParamName(i), PARAM_SESSIONID ) )
                {
                        session_id = request->getParamValue(i);
                        break;
                }
        }
        
        if (session_id == NULL)
        {
                ZLOG(ZLT_ERROR,"参数缺少SessionID");
                return false;
        }
        
        SESSION_T *pSession = CSessionMgr::GetInstancePtr()->FindUserSession(session_id);
        
        if (pSession == NULL)
        {
                return false;
        }

        pConn->pSession = pSession;
        return true;
}

