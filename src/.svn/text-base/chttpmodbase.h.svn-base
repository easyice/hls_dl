/*
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2012  elva <email>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#ifndef CHTTPMODULEBASE_H
#define CHTTPMODULEBASE_H

#include "cconnectionmgr.h"
#include "sphttpmsg.hpp"
#include "define.h"
#include "global.h"

typedef enum _EM_MIME_TYPE_T
{
        MIME_M3U8,
        MIME_TS,
        MIME_CHUNK
}EM_MIME_TYPE_T;

class CHttpModBase
{
public:
	CHttpModBase();
	
	void SetParam(char* pHead,int nHeadSize,BYTE* pBody,int nBodySize);
	virtual ~CHttpModBase();
	
	virtual SEND_RES_T ProcessNewRequest(SP_HttpRequest * request,CONNECTION_T* pConn) = 0;
	
	/**
         * @brief 非首次处理 请求
         * @return 0,没有要发送的数据，1，待发数据已放入 m_pSendBuf
         */
        virtual int OnRequestContinue(CONNECTION_T* pConn) = 0;
	
        /**
         * @brief EPOLL_OUT 事件响应
         */
        SEND_RES_T ProcessContinue(CONNECTION_T* pConn);
        
	/**
	 * @brief 发送用户缓冲中的剩余数据
	 */
	SEND_RES_T SendBufferedData(CONNECTION_T* pConn);
	
        /**
         * @brief EPOLL_OUT 响应Range:0-1,ios特有请求，不严谨的处理，仅返回#
         */
        SEND_RES_T OnRequestRange01(CONNECTION_T* pConn);
protected:
	/**
	 * @brief 解析请求并组织返回数据到m_pSendBuf
	 * @return 0,没有要发送的数据，1，待发数据已放入 m_pSendBuf
	 */
	virtual int OnRequest(SP_HttpRequest * request,CONNECTION_T* pConn,int& status) = 0;
	
	/**
	 * @brief 为缓冲中的数据添加HTTP头并发送
	 */
	virtual SEND_RES_T HttpSendBuffer(CONNECTION_T* pConn,bool bAddHead) = 0;
	
	/**
	 * @brief 生成 Http Header
	 */
	virtual void GenHttpHead(int content_len) = 0;

protected:	
	/**
	 * @brief 异步发送数据
	 * @param pData 待发数据缓冲
	 * @param nLen 数据长度
	 * @return RES_ERROR 发送异常，应当 做断开处理; RES_AGAIN 发送缓冲区满; >0 实际发送数据长度
	 */
	int Send(int sock,BYTE* pData,int nLen);
	
	/**
	 * @brief 发送数据，如果底层缓冲满，就拷贝到用户缓冲
	 */
	SEND_RES_T SendOrCopyToUserBuffer(BYTE* pData,int nLen,CONNECTION_T* pConn);
        
        /**
         * @brief 拷贝到用户缓冲
         */
        bool CopyToUserBuffer(BYTE* pData,int nLen,CONNECTION_T* pConn);
	

	/**
	 * @brief 用户缓冲可以容纳客户请求产生的应答数据
	 */
	SEND_RES_T ProcessNewRequestCommOnce(SP_HttpRequest * request,CONNECTION_T* pConn);
	
	/**
	 * @brief 用户缓冲可能无法容纳客户请求产生的应答数据，可能需多次处理的
	 */
	SEND_RES_T ProcessNewRequestCommMuti(SP_HttpRequest * request,CONNECTION_T* pConn);
	
        
        
        /**
         * @brief RESET 临时缓冲
         */
	void ResetTmpBuffer();
        
        int Response404();
        int Response500();
        int Response200(EM_MIME_TYPE_T emMime,int content_len);
protected:
	
	//临时缓冲，
	BYTE *m_pSendBuf;
	
	//数据长度
	int m_nSendBufLen;
	
	//缓冲大小
	int m_nSendBufSize;
	
	char* m_pHttpHead;
	
	int m_nHttpHeadLen;
	
	int m_nHttpHeadSize;	
};

#endif // CHTTPMODULEBASE_H
