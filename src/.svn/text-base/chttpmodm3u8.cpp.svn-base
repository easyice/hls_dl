/*
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2012  elva <email>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#include "chttpmodm3u8.h"
#include "cplaystatistics.h"
#include "ctsreadervod.h"
#include "ctsreadertstv.h"
#include "protocal.h"
#include "ctsreadervfs.h"
#include "ctsreaderlive.h"


CHttpModM3u8::CHttpModM3u8()
{

}

CHttpModM3u8::~CHttpModM3u8()
{

}

SEND_RES_T CHttpModM3u8::ProcessNewRequest(SP_HttpRequest* request, CONNECTION_T* pConn)
{
        return ProcessNewRequestCommOnce(request,pConn);
}


int CHttpModM3u8::OnRequest(SP_HttpRequest* request, CONNECTION_T* pConn,int& status)
{
       
        if (IsMultiRateReq(request))
        {
                if (GenMultiRateList(request))
                {
                        GenHttpHead(m_nSendBufLen);
                        status = 200;
                        return 1;
                }
        }
        
	//新的点播请求，初始化打开文件
        assert(pConn->pSession != NULL);
        if (pConn->pSession->pTsReader == NULL)
        {
                //do open
                if ( !InitSession(request,pConn->pSession) )
                {
                        status = 500;
                        return Response500();
                }
            
                //点播统计
                CPlayStatistics::GetInstancePtr()->ReportProgramName(NULL);
        }
	
	m_nSendBufLen = pConn->pSession->pM3u8Gen->GenList((char*)m_pSendBuf,m_nSendBufSize);

        if (m_nSendBufLen <= 0)
        {
                status = 500;
                return Response500();
        }
        
        GenHttpHead(m_nSendBufLen);
        
        status = 200;
	return 1;
}

SEND_RES_T CHttpModM3u8::HttpSendBuffer(CONNECTION_T* pConn, bool bAddHead)
{
	SEND_RES_T ret = RES_SUCCESS;
    
        if (bAddHead)
        {   
                if ( (ret = SendOrCopyToUserBuffer((BYTE*)m_pHttpHead,m_nHttpHeadLen,pConn)) == RES_ERROR )
                {    
                        return RES_ERROR;
                }   
                else if (ret == RES_AGAIN)
                {   
                        CopyToUserBuffer(m_pSendBuf,m_nSendBufLen,pConn);
                        return RES_AGAIN;
                }   
        }   

        return SendOrCopyToUserBuffer(m_pSendBuf,m_nSendBufLen,pConn);
}

void CHttpModM3u8::GenHttpHead(int content_len)
{
        int code = 200;
        char msg[] = "OK";
        char type[] = "application/x-mpegURL";
        
        int bytes = sprintf((char*)m_pHttpHead,"HTTP/1.1 %d %s\r\n", code, msg);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Content-type: %s\r\n", type);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Server: %s\r\n",SERVER_LOGO);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Connection: keep-alive\r\n");
        bytes += sprintf((char*)m_pHttpHead + bytes,"Content-Length: %d\r\n\r\n", content_len);

        m_nHttpHeadLen = bytes;
}

bool CHttpModM3u8::InitSession(SP_HttpRequest* request, SESSION_T* pSession)
{
        using namespace vs_protocal;
        
       
        
        OVT_STRU_CREATE_USER_OBJ_INFO stObjInfo;
        stObjInfo.strVolume = "ovtmass";
        stObjInfo.llStartPoint = 0;
        stObjInfo.llEndTime = 0xFFFFFFFF;
        
        string strSession;
        string strServiceType;
        for( int i = 0; i < request->getParamCount(); i++ )
        {
                if( 0 == strncasecmp(request->getParamName(i),PARAM_AID,strlen(PARAM_AID)) )
                {
                        stObjInfo.strAssetId = request->getParamValue(i);
                }
                else if( 0 == strncasecmp(request->getParamName(i),PARAM_PID,strlen(PARAM_PID)) )
                {
                        stObjInfo.strProviderId = request->getParamValue(i);
                }
                else if( 0 == strcasecmp(request->getParamName(i),PARAM_SP) )
                {
                        stObjInfo.llBeginTime = atoll(request->getParamValue(i));
                }
                else if( 0 == strcasecmp(request->getParamName(i),PARAM_SESSIONID) )
                {
                        strSession = request->getParamValue(i);
                }
                else if( 0 == strcasecmp(request->getParamName(i),PARAM_ST) )
                {
                        strServiceType = request->getParamValue(i);
                }

        }
        
        if (0 == strcasecmp(strServiceType.c_str(),PARAM_ST_VOD))
        {
                pSession->pTsReader = new CTsReaderVod();
        }
        else if (0 == strcasecmp(strServiceType.c_str(),PARAM_ST_TSTV))
        {
                pSession->pTsReader = new CTsReaderTstv();
        }
        else if (0 == strcasecmp(strServiceType.c_str(),PARAM_ST_VFS))
        {
                pSession->pTsReader = new CTsReaderVfs();
        }
        else if (0 == strcasecmp(strServiceType.c_str(),PARAM_ST_LIVE))
        {
                pSession->pTsReader = new CTsReaderLive();
        }
        
        if (pSession->pTsReader == NULL)
        {
                return false;
        }
        
        pSession->pM3u8Gen = new CM3U8Gen();
        
        if ( !pSession->pTsReader->Open(stObjInfo) )
        {
                delete pSession->pTsReader;
                pSession->pTsReader = NULL;
                ZLOG(ZLT_ERROR,"打开文件失败!",V(stObjInfo.strAssetId));
                
                return false;
        }
        
        pSession->pM3u8Gen->Init(strSession,strServiceType,stObjInfo.strAssetId,stObjInfo.strProviderId,1);
        pSession->pM3u8Gen->UpdateFileName(0);
        
        return true;
}

bool CHttpModM3u8::IsMultiRateReq(SP_HttpRequest* request)
{
        using namespace vs_protocal;
        
        int count = 0;
        for( int i = 0; i < request->getParamCount(); i++ )
        {
                if( 0 == strncasecmp(request->getParamName(i),PARAM_AID,strlen(PARAM_AID)) )
                {
                        count++;
                }
        }
        
        if (count > 1)
        {
                return true;
        }
        
        return false;
}

bool CHttpModM3u8::GenMultiRateList(SP_HttpRequest* request)
{
  return true;
}

int CHttpModM3u8::OnRequestContinue(CONNECTION_T* pConn)
{
        return 0;
}

