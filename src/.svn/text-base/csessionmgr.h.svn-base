/*
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2012  elva <email>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#ifndef CSESSIONMGR_H
#define CSESSIONMGR_H


#include "ctsreaderbase.h"
#include "cspeedctrl.h"
#include "cm3u8gen.h"
#include "define.h"
#include <zsafeobjpool.h>
#include <map>



typedef struct _SESSION_T
{
	_SESSION_T()
	{
		pTsReader = NULL;
		pM3u8Gen = NULL;
		bUseing = false;
                bEof = false;
                nReadedGop = 0;
                updateTime = 0;
	}
	
	//最后活动时间
	time_t updateTime;
	
        //是否有连接在使用会话
	bool bUseing;
	
        //已读取的GOP计数
        int nReadedGop;
        
        //是否已读取完毕
        bool bEof;
        
	pthread_mutex_t mutex;
	
	/********************用户退出销毁*********************/
	CTsReaderBase* pTsReader;
	CM3U8Gen* pM3u8Gen;
	
}SESSION_T;


///会话管理
class CSessionMgr
{
public:
	~CSessionMgr();
	static CSessionMgr* GetInstancePtr();
	
	//先调用以下两个函数进行初始化
	
	/**
	 * @param maxuser 最大并发用户数量
	 */
	bool Init(int maxuser);
	
	/**
	 * @brief 为用户分配会话资源。内部执行锁保护.如果已有返回现有的，否则申请一个
	 */
	SESSION_T* AllocUserSession(const string& strSessionId,bool bAllowReuse);
	
        /**
         * @brief 获取现有用户会话
         */
        SESSION_T* FindUserSession(const string& strSessionId);
        
	/**
	 * @brief 关闭socket，释放会话资源
	 */
	void FreeUserSession(const string& strSessionId);
        
        int GetUserCount();
        
        void SetUserTimeOut(time_t nTimeOut);
        
        /**
         * @brief 检测并踢出超时用户
         */
        void CheckTimeOut();
private:
	CSessionMgr();
	
        void ClearSessionResource(SESSION_T* pSession);
private:
	static CSessionMgr* m_pStatic;

	map<string,SESSION_T*> m_mapSessionIdx;
	
	ZSafeObjPool<SESSION_T> *m_pSessionPoll;
	
	int m_nMaxUser;
	
	int m_nCurUserCount;
	
	pthread_mutex_t m_mutex;
        
        //秒
        time_t m_nTimeOut;
};

#endif // CSESSIONMGR_H
