/*
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2012  elva <email>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "define.h"
#include "chttpserver.h"
#include "global.h"

#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
#include <netinet/tcp.h>
#include <fcntl.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <netdb.h>
#include <zapp.h>




extern bool g_bIpv6;


CHttpServer::CHttpServer()
{
	m_nFdCount = 0;
	m_nCurFdIndex = 0;
	m_strPort = "80";
        m_pListenEv = new CONNECTION_T();
}

CHttpServer::~CHttpServer()
{
        delete m_pListenEv;
}

void CHttpServer::SetListenPort(const string& port)
{
	m_strPort = port;
}


bool CHttpServer::Init()
{
	/* Don't die with SIGPIPE on remote read shutdown. That's dumb. */
	signal( SIGPIPE, SIG_IGN );
	
	if (!OpenListening())
	{
		return false;
	}
	
	return true;
}

bool CHttpServer::OpenListening()
{
        const int on = 1;
        struct epoll_event ev;

        struct addrinfo hints;
        struct addrinfo *local_res;
        struct addrinfo *local_res_temp;
        memset(&hints,0,sizeof(hints));
        
        m_nEpfd = epoll_create(MAX_USER_FD);
        
        if (m_nEpfd < 0)
        {
                ZLOG(ZLT_ERROR, "epoll_create failed!!!", LASTERROR);
                return false;
        }
        
        CConnectionMgr::GetInstancePtr()->SetEpollFd(m_nEpfd);
        
        if (g_bIpv6)
        {
                hints.ai_family = AF_INET6;
                ZLOG(ZLT_USER,"Server Runing at ipv6");
        }
        else
        {
                hints.ai_family = AF_INET;
        }
        
        hints.ai_socktype = SOCK_STREAM;
        hints.ai_protocol = IPPROTO_TCP;
        hints.ai_flags = AI_PASSIVE;
        
        int count = 0;
        int error = 0;
        do
        {
                error = getaddrinfo(NULL,m_strPort.c_str(),&hints,&local_res);
                count += 1;
                if (error == EAI_AGAIN)
                {
                        ZLOG(ZLT_ERROR,"Sleeping on getaddrinfo EAI_AGAIN");
                }
                sleep(1);
        } while ((error == EAI_AGAIN) && (count <= 5));
        
        if (error != 0)
        {
                ZLOG(ZLT_ERROR, "getaddrinfo failed!!!", LASTERROR);
                return false;
        }
        
        local_res_temp = local_res;
        
        //应该只有一次循环
        do
        {
                m_nListenfd = socket(local_res_temp->ai_family,SOCK_STREAM,0);
                if (m_nListenfd < 0)
                {
                        ZLOG(ZLT_ERROR, "could not allocate a socket,try next.", LASTERROR);
                        continue;
                }
                
                if ( set_non_blocking_mode(m_nListenfd) < 0 )
                {
                        ZLOG(ZLT_ERROR,"set_non_blocking_mode failed!!!",LASTERROR);
                        close(m_nListenfd);
                        m_nListenfd = -1;
                        continue;
                }
                if ( setsockopt( m_nListenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) != 0)
                {
                        ZLOG(ZLT_ERROR, "Set SO_REUSEADDR failed,try next.", LASTERROR);
                        close(m_nListenfd);
                        m_nListenfd = -1;
                        continue;
                }

                if ( setsockopt( m_nListenfd, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof(on)) == -1)
                {
                        ZLOG(ZLT_ERROR, "Set TCP_NODELAY failed,try next.", LASTERROR);
                        close(m_nListenfd);
                        m_nListenfd = -1;
                        continue;
                }
                if (bind( m_nListenfd,local_res_temp->ai_addr,local_res_temp->ai_addrlen) != 0 )
                {
                        ZLOG(ZLT_ERROR, "bind failed!!!", LASTERROR);
                        close(m_nListenfd);
                        m_nListenfd = -1;
                        continue;
                }
                break;
        } while ( (local_res_temp = local_res_temp->ai_next) != NULL);

        freeaddrinfo(local_res);
        if (m_nListenfd < 0)
        {
                ZLOG(ZLT_ERROR, "Create web server socket failed!!!", LASTERROR);
                close(m_nEpfd);
                return false;
        }

	//add to epoll
	m_pListenEv->sock = m_nListenfd;
	ev.data.ptr = m_pListenEv;
	ev.events=EPOLLIN; //不可使用ET模式，因为每次只accpet了一次，没有读完
	
	epoll_ctl(m_nEpfd,EPOLL_CTL_ADD,m_nListenfd,&ev);

	if  ( listen(m_nListenfd, 128) < 0)
	{
		ZLOG(ZLT_ERROR, "Web server listen failed!!!", LASTERROR);
		goto failed;
	}

        
	return true;
failed:
        close(m_nListenfd);
        close(m_nEpfd);
        return false;

}

epoll_event CHttpServer::WaitForOneEvent()
{
	epoll_event epEv;
	while (1)
	{
		for (;m_nCurFdIndex < m_nFdCount;m_nCurFdIndex++)
		{
                        CONNECTION_T* pConn = (CONNECTION_T*)(m_events[m_nCurFdIndex].data.ptr);
                        if(pConn->sock==m_nListenfd)
                        {
                                OnAccept();
                                continue;
                        }
                        
                        vs_log(LV_DEBUG_EV,"m_nCurFdIndex=%d,m_nFdCount=%d,tid=%d",
                                m_nCurFdIndex,m_nFdCount,gettid());
                        epEv =  m_events[m_nCurFdIndex++];
                        
                        return epEv;
		}
		
		//sleep(10);
		m_nFdCount=epoll_wait(m_nEpfd,m_events,MAX_WAIT_EVENTS,2000);
                 vs_log(LV_DEBUG_EV,"epoll_wait return:%d",m_nFdCount);
                 
		m_nCurFdIndex = 0;
		
	}
}

void CHttpServer::OnAccept()
{
        vs_log(LV_DEBUG_EV,"OnAccept,listen fd=%d",m_nListenfd);
        
        struct sockaddr_storage cliaddr;
        socklen_t stLen = sizeof(cliaddr);
        memset(&cliaddr,0,stLen);
        
        int sock = accept(m_nListenfd,(sockaddr *)&cliaddr, &stLen);
        
        if(sock < 0)
        {
                ZLOG(ZLT_ERROR, "Web server accept failed!!!",LASTERROR);
                return;
        }
        
        //设置 sock 属性
        int i_Pos = 1;
        if ( setsockopt( sock, IPPROTO_TCP, TCP_NODELAY, (char *)&i_Pos, sizeof(i_Pos)) == -1)
        {
                ZLOG(ZLT_ERROR, "Set web client TCP_NODELAY failed!!!", LASTERROR);
                close(sock);
                return;
        }
        
        if (set_non_blocking_mode(sock) < 0)
        {
                ZLOG(ZLT_ERROR,"set_non_blocking_mode failed!!!",LASTERROR);
                close(sock);
                return;
        }
        
        //为新用户分配连接
        CONNECTION_T *pConn = CConnectionMgr::GetInstancePtr()->AllocConnection(sock);
        if (pConn == NULL)
        {
                ZLOG(ZLT_ERROR,"为用户分配 connection 失败",V(sock));
                close(sock);
                return;
        }
        
        //add to epoll
        struct epoll_event ev;

        ev.data.ptr = pConn;
        ev.events=EPOLLIN | EPOLLRDHUP | EPOLLOUT |EPOLLET;
        epoll_ctl(m_nEpfd,EPOLL_CTL_ADD,sock,&ev);
                
        //连接信息
        struct sockaddr sa;
        socklen_t serv_len = sizeof(sa);
        char s_hbuf[NI_MAXHOST];
        char s_sbuf[NI_MAXSERV];
        char c_hbuf[NI_MAXHOST];
        char c_sbuf[NI_MAXSERV];
        
        getsockname(sock, (struct sockaddr *)&sa, &serv_len); 
        getnameinfo(&sa,serv_len,s_hbuf,sizeof(s_hbuf),s_sbuf,sizeof(s_sbuf), NI_NUMERICHOST | NI_NUMERICSERV);
        getnameinfo((sockaddr *)&cliaddr,stLen,c_hbuf,sizeof(c_hbuf),c_sbuf,sizeof(c_sbuf), NI_NUMERICHOST | NI_NUMERICSERV);
        //getsockname(sock, (struct sockaddr *)&serv, &serv_len);  
        //getpeername(sock, (struct sockaddr *)&guest, &guest_len);
        //inet_ntop(AF_INET, &serv.sin_addr, server_ip, sizeof(server_ip));  
        //inet_ntop(AF_INET, &sinRemoteAddr.sin_addr, client_ip, sizeof(client_ip));  
        
        //ZLOG(ZLT_INFO,"收到新连接",V(server_ip),V(client_ip),V(sock));
        vs_log(LV_USER,"新连接,server_ip=%s,client_ip=%s,sock=%d,连接数=%d",
               s_hbuf,c_hbuf,sock,CConnectionMgr::GetInstancePtr()->GetConnectionCount());

}

int CHttpServer::GetEpFd()
{
        return m_nEpfd;
}

int CHttpServer::GetListenFd()
{
        return m_nListenfd;
}
