#include <stdio.h>
#include <string>
#include "chttpserver.h"
#include "clfthreadpoll.h"
#include "csessionmgr.h"
#include "define.h"
#include "MuxLog.h"
#include "cconnectionmgr.h"
#include "cwebinterface.h"

#include <libobj.h>
#include <getopt.h>
#include <unistd.h>

using namespace std;


string g_monModName = "ott_vss";
string g_monModVer  = "1.0.0.0";



// DEF_ZMOD_APP("rtr","NGOD分发接收服务","3.0.0.4.0");
// ZMOD_HISTORY_BEGIN
// 	ZMOD_HISTORY("2012-04-26 16:50:00","3.0.0.4.0","写入完毕时删除不完整的index文件");
// ZMOD_HISTORY_END;

/**
 * 1.由于为了兼容vlc,m3u8开始时加入了若干条假的ts链接。只有1条是无法播放的。
 * 这造成每条链接都不对应。解决办法：libobj提供peek接口
 * 2.等待用户完成会阻塞线程,很短一小会
 * 3.禁止并发的TS请求，当终端刷新播放页面时，有时会产生并发的TS请求。被禁止后，终端停播。
 */



string		g_strTestRootPath;
int             g_nUserWBufferSize      = 4096*32;
int             g_nGopPerSeg            = 1;
int             g_nDurationPerSeg       = 1;
bool            g_bIpv6                 = false;
static string	g_strListenPort 	= "80";
static int 	g_nMaxUserAllow		= 1000;
static int 	g_nWorkThread		= 10;
static int      g_nUserTimeOut          = 60*10;
static int      g_nConnTimeOut          = 60;
static int      g_nLogLevel             = 2;

void GetConfig()
{

 	g_strTestRootPath = (const string &)ZCONF_GET("/OTT_VSS/TestRootPath","/mnt/","测试使用的根目录");
	if (g_strTestRootPath[g_strTestRootPath.size() -1] != '/')
        {
             g_strTestRootPath += "/";
        }

        g_strListenPort = (const string &)ZCONF_GET("/OTT_VSS/ListenPort","80","服务端口");
	g_nUserWBufferSize = ZCONF_GET("/OTT_VSS/UserWBufferSize",40960,"每用户输出缓冲大小");
	g_nMaxUserAllow = ZCONF_GET("/OTT_VSS/MaxUserAllowed",1000,"支持的最大并发用户数量");
	g_nWorkThread = ZCONF_GET("/OTT_VSS/WorkThreadCount",10,"工作线程数量");
        g_nGopPerSeg = ZCONF_GET("/OTT_VSS/GopPerSeg",1,"每个虚拟切片中GOP数量");
        g_nDurationPerSeg = ZCONF_GET("/OTT_VSS/DurationPerSeg",1,"每个虚拟切片的时长");
        g_nUserTimeOut = ZCONF_GET("/OTT_VSS/UserTimeOut",600,"用户超时时间（单位：秒）");
        g_nConnTimeOut = ZCONF_GET("/OTT_VSS/ConnectionTimeOut",60,"连接超时时间（单位：秒）");
}

void InitLibs()
{
        string strManIp = (const string &)ZCONF_GET("/MAN/IpAdderss","127.0.0.1","MAN服务器地址");
        int nManPort = ZCONF_GET("/MAN/Port",7000,"MAN服务器端口");
        int nChannel = ZCONF_GET("/MAN/ChannelID",331,"通道ID");
        int nMaxFiles = ZCONF_GET("/MAN/MaxFiles",1000,"同时打开最大文件数");
        InitLibObj(strManIp,nManPort,nChannel,nMaxFiles);
        
        ZLOG(ZLT_USER,"初始化 LIBOBJ，等待5秒");
        sleep(5);
}

void main_loop()
{
        while(1)
        {
                sleep(10);
                CSessionMgr::GetInstancePtr()->CheckTimeOut();
                CConnectionMgr::GetInstancePtr()->CheckTimeOut();
        }
}

void usage(char *name)
{
        cout << "USAGE: "<< name <<" [OPTION]" << endl;
        cout << " -l set loglevel" << endl;
        cout << " -4 use ipv4 (default)" << endl;
        cout << " -6 use ipv6" << endl;
        cout << " -h this help" << endl;
        exit(0);
}

void scan_args(int argc,char **argv)
{
        struct option longopts[]=
        {
                {"loglevel",required_argument,NULL,'l'},
                {"4",no_argument,NULL,'4'},
                {"6",no_argument,NULL,'6'},
                {"help",no_argument,NULL,'h'},
                {0,0,0,0},
        };
        
        int c;
        while ( ( c = getopt_long_only ( argc,argv,"46l:",longopts,NULL ) ) != -1 )
        {
                switch ( c )
                {
                        case 'l':
                                g_nLogLevel = atoi(optarg);
                                break;
                        case '4':
                                g_bIpv6 = false;
                                break;
                        case '6':
                                g_bIpv6 = true;
                                break;
                        case 'h':
                                usage(argv[0]);
                                break;
                }
        }
}

int main(int argc,char **argv)
{
	if (argc > 1)
	{
                scan_args(argc,argv);
	}
	
	GetConfig();

        InitLibs();
        
        CMuxLog::GetInstancePtr()->SetLogLevel(g_nLogLevel);

	CSessionMgr::GetInstancePtr()->Init(g_nMaxUserAllow);
        CSessionMgr::GetInstancePtr()->SetUserTimeOut(g_nUserTimeOut);
	CConnectionMgr::GetInstancePtr()->Init(g_nMaxUserAllow*2,g_nUserWBufferSize);
        CConnectionMgr::GetInstancePtr()->SetConnectionTimeOut(g_nConnTimeOut);
	
	CHttpServer *pHttpServer = new CHttpServer();
	pHttpServer->SetListenPort(g_strListenPort);
	pHttpServer->Init();
	
	CLFThreadPoll* pLfThreadPoll = new CLFThreadPoll(pHttpServer);
	pLfThreadPoll->SetMaxThreads(g_nWorkThread);
	pLfThreadPoll->Start();

        CWebInterface *pWebInterface = new CWebInterface();
        pWebInterface->Regist();
        
        ZLOG(ZLT_USER,"系统启动完毕");
        
	main_loop();
	return 0;
}
