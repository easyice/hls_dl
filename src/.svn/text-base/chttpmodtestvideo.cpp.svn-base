/*
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2012  elva <email>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#include "chttpmodtestvideo.h"
#include "protocal.h"
#include "ctsreaderstd.h"
#include <stdio.h>
#include <sys/stat.h>



extern string g_strTestRootPath;


CHttpModTestVideo::CHttpModTestVideo()
{

}

CHttpModTestVideo::~CHttpModTestVideo()
{

}

SEND_RES_T CHttpModTestVideo::ProcessNewRequest(SP_HttpRequest* request, CONNECTION_T* pConn)
{
	return ProcessNewRequestCommMuti(request,pConn);
}

int CHttpModTestVideo::OnRequest(SP_HttpRequest* request, CONNECTION_T* pConn,int& status)
{
	using namespace vs_protocal;

	assert(pConn->pSession != NULL);
	if (pConn->pSession->pTsReader == NULL)
	{
		//do open
		pConn->pSession->pTsReader = new CTsReaderStd();
	}
	
	string uri = request->getURI();
	string pathname = g_strTestRootPath + (uri.c_str() + strlen(URI_TEST_VIDEO)+1);
	EM_MIME_TYPE_T mime_type;
	string ext = uri.substr(uri.rfind("."),uri.length());
	string open_mode;
	
	if (0 == strcasecmp( ext.c_str(), ".ts" ))
	{
		mime_type = MIME_TS;
		open_mode = "rb";
	}
	else if (0 == strcasecmp( ext.c_str(), ".m3u8" ))
	{
		mime_type = MIME_M3U8;
		open_mode = "r";
	}
	
	vs_log(LV_DEBUG_EV,"sock=%04d,open file:%s,tid=%ld,status=%d",pConn->sock,
		  pathname.c_str(),gettid(),pConn->pStatus->GetStatus());
	

	if (access(pathname.c_str(),F_OK) != 0)
	{
                status = 404;
		return Response404();
	}
	
	if (!pConn->pSession->pTsReader->Open(pathname,open_mode.c_str()))
	{
                status = 500;
		return Response500();
	}
	
	
		
	struct stat st;
	stat(pathname.c_str(),&st);
	
        status = 200;
	return Response200(mime_type,st.st_size);
}

SEND_RES_T CHttpModTestVideo::HttpSendBuffer(CONNECTION_T* pConn, bool bAddHead)
{
	SEND_RES_T ret = RES_SUCCESS;
	
	if (bAddHead)
	{
                if ( (ret = SendOrCopyToUserBuffer((BYTE*)m_pHttpHead,m_nHttpHeadLen,pConn)) == RES_ERROR )
                {	 
                        return RES_ERROR;
                }
                else if (ret == RES_AGAIN)
                {
                        CopyToUserBuffer(m_pSendBuf,m_nSendBufLen,pConn);
                        return RES_AGAIN;
                }
	}

	return SendOrCopyToUserBuffer(m_pSendBuf,m_nSendBufLen,pConn);
}

void CHttpModTestVideo::GenHttpHead(int content_len)
{

}

int CHttpModTestVideo::OnRequestContinue(CONNECTION_T* pConn)
{
	if (pConn->pStatus->GetStatus() == ST_PROCCESSED)
	{
		return 0;
	}
	
	//read file and send
	m_nSendBufLen = pConn->pSession->pTsReader->Read(m_pSendBuf,m_nSendBufSize);
	vs_log(LV_DEBUG_IO,"sock=%04d,read file:%d", pConn->sock,m_nSendBufLen);

	
	if (m_nSendBufLen != m_nSendBufSize)
	{
		pConn->pSession->pTsReader->Close();
		
		vs_log(LV_DEBUG_EV,"sock=%04d,read finish,close file.m_nSendBufLen=%d",pConn->sock,m_nSendBufLen);
		pConn->pStatus->SetStatus(ST_PROCCESSED);
		m_nSendBufLen = max(0,m_nSendBufLen);
		m_nSendBufLen += sprintf((char*)m_pSendBuf+m_nSendBufLen,"%s", "\r\n"); //可以不加
	}

	return m_nSendBufLen;
}

