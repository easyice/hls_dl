/*
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) 2012  elva <email>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#include "chttpmodbase.h"
#include <errno.h>

CHttpModBase::CHttpModBase()
{
	
}

CHttpModBase::~CHttpModBase()
{

}

void CHttpModBase::SetParam(char* pHead, int nHeadSize, BYTE* pBody, int nBodySize)
{
	m_pHttpHead = pHead;
	m_nHttpHeadLen = 0;
	m_nHttpHeadSize = nHeadSize;
	
	m_pSendBuf = pBody;
	m_nSendBufLen = 0;
	m_nSendBufSize = nBodySize;
}

int CHttpModBase::Send(int sock, BYTE* pData, int nLen)
{
	if (nLen <= 0)
	{
		return 0;
	}
	
	int iSendedLen = send(sock, pData, nLen, 0);
	
	if (iSendedLen < 0)
	{
		if (errno == EAGAIN/*||errno == EINTR || errno == EWOULDBLOCK*/)
		{
			return RES_AGAIN;
		}
		else
		{
			return RES_ERROR;
		}
	}
	else if (iSendedLen == 0)
	{
		ZLOG(ZLT_ERROR,"send函数返回0,这是什么情况？",V(nLen));
		return RES_ERROR;
	}
	
	return iSendedLen;
}

SEND_RES_T CHttpModBase::SendOrCopyToUserBuffer(BYTE* pData, int nLen, CONNECTION_T* pConn)
{
        if (nLen <= 0)
        {
                return RES_SUCCESS;
        }
        
	SEND_RES_T ret = RES_SUCCESS;
        
	int iSendedLen = Send(pConn->sock,pData,nLen);
	
	if (iSendedLen > 0)
	{
		vs_log(LV_DEBUG_IO,"sock=%04d,write size=%d,firstbyte=0x%X",pConn->sock,iSendedLen,pData[0]);
	}

	if (iSendedLen > 0 && iSendedLen != nLen)
	{
		pConn->pWriteBuffer->AddData(pData+iSendedLen,nLen-iSendedLen);
		ret = RES_AGAIN;
	}
	else if (iSendedLen == RES_AGAIN)
	{
		pConn->pWriteBuffer->AddData(pData,nLen);
		ret = RES_AGAIN;
	}
	else if (iSendedLen == RES_ERROR)
	{
		ret = RES_ERROR;
		ZLOG(ZLT_ERROR,"Send Error",LASTERROR,V(pConn->sock),V(errno));
	}
	
	return ret;
}

bool CHttpModBase::CopyToUserBuffer(BYTE* pData, int nLen, CONNECTION_T* pConn)
{
        return pConn->pWriteBuffer->AddData(pData,nLen);
}

SEND_RES_T CHttpModBase::SendBufferedData(CONNECTION_T* pConn)
{
	if (pConn->pWriteBuffer->GetDataLen() > 0)
	{
		int iSendedLen = Send(pConn->sock,pConn->pWriteBuffer->GetBufferPtr(),
				      pConn->pWriteBuffer->GetDataLen());
		if (iSendedLen > 0 && iSendedLen != pConn->pWriteBuffer->GetDataLen())
		{
			pConn->pWriteBuffer->RemovePart(iSendedLen);
			return RES_AGAIN;
		}
		else if (iSendedLen == RES_AGAIN)
		{
			return RES_AGAIN;
		}
		else if (iSendedLen == RES_ERROR)
		{
			ZLOG(ZLT_ERROR,"Send Error",LASTERROR,V(pConn->sock),V(errno));
			return RES_ERROR;
		}
		else // 剩余数据发送完毕
		{
			pConn->pWriteBuffer->ReSetBuffer();
		}
	}
	
	return RES_SUCCESS;
}

void CHttpModBase::ResetTmpBuffer()
{
	m_nSendBufLen = 0;
	m_nHttpHeadLen = 0;
}

SEND_RES_T CHttpModBase::OnRequestRange01(CONNECTION_T* pConn)
{
        ResetTmpBuffer();
        Response200(MIME_M3U8,1);
        m_pHttpHead[m_nHttpHeadLen] = '#';
        m_nHttpHeadLen++;
        SendOrCopyToUserBuffer((BYTE*)m_pHttpHead,m_nHttpHeadLen,pConn);
        return RES_ACTIVE_CLOSE;
}

SEND_RES_T CHttpModBase::ProcessNewRequestCommOnce(SP_HttpRequest* request, CONNECTION_T* pConn)
{
        ResetTmpBuffer();
        
        vs_log(LV_USER,"新请求 url=%s,tid=%d",request->getURL(),gettid());
        
        SEND_RES_T ret = RES_SUCCESS;
        int status;
        
        if ( OnRequest(request,pConn,status) > 0 )
        {
                ret = HttpSendBuffer(pConn,true);
        }
        
        return ret;
}

SEND_RES_T CHttpModBase::ProcessNewRequestCommMuti(SP_HttpRequest* request, CONNECTION_T* pConn)
{
        ResetTmpBuffer();
        
        vs_log(LV_USER,"新请求 url=%s,tid=%d",request->getURL(),gettid());
        
        SEND_RES_T ret = RES_SUCCESS;
        int status = 0;
        
        if (OnRequest(request,pConn,status) <= 0)
        {
                return RES_SUCCESS;
        }
        
        if ( (ret = HttpSendBuffer(pConn,true)) != RES_SUCCESS)
        {
                return ret;
        }
        if (status != 200)
        {
                return ret;
        }
        
        ResetTmpBuffer();
        while (OnRequestContinue(pConn) > 0)
        {
                if ( (ret=HttpSendBuffer(pConn,false)) != RES_SUCCESS)
                {
                        return ret;
                }
                ResetTmpBuffer();
        }
        return ret;
}

SEND_RES_T CHttpModBase::ProcessContinue(CONNECTION_T* pConn)
{
        ResetTmpBuffer();
        
        SEND_RES_T emRet = RES_SUCCESS;
        while (OnRequestContinue(pConn) > 0)
        {
                if ( (emRet = HttpSendBuffer(pConn,false)) != RES_SUCCESS )
                {
                        return emRet;
                }
                ResetTmpBuffer();
        }
        return emRet;
}


int CHttpModBase::Response404()
{
        //body
        m_nSendBufLen = sprintf((char*)m_pSendBuf,"%s", "<html>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "<head>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "<title>Error 404 (Not Found)!!!</title>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "</head>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "<body bgcolor=\"white\" text=\"black\">\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "<br><br><br>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "<h1>not found!</h1>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "</body>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "</html>\r\n");
        
        //head
        int code = 404;
        char msg[] = "Not Found";
        char type[] = "text/html";

        int bytes = sprintf((char*)m_pHttpHead,"HTTP/1.1 %d %s\r\n", code, msg);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Content-type: %s\r\n", type);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Server: %s\r\n",SERVER_LOGO);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Connection: close\r\n");
        bytes += sprintf((char*)m_pHttpHead + bytes,"Content-Length: %d\r\n\r\n", m_nSendBufLen);
        

        m_nHttpHeadLen = bytes;
        
        return 1;
}

int CHttpModBase::Response500()
{
        //body
        m_nSendBufLen = sprintf((char*)m_pSendBuf,"%s", "<html>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "<head>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "<title>Error 500 (Internel Server Error)!!!</title>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "</head>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "<body bgcolor=\"white\" text=\"black\">\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "<br><br><br>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "<h1>Internel Server Error!</h1>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "</body>\r\n");
        m_nSendBufLen += sprintf((char*)m_pSendBuf + m_nSendBufLen ,"%s", "</html>\r\n");
        
        //head
        int code = 500;
        char msg[] = "Not Found";
        char type[] = "text/html";

        int bytes = sprintf((char*)m_pHttpHead,"HTTP/1.1 %d %s\r\n", code, msg);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Content-type: %s\r\n", type);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Server: %s\r\n",SERVER_LOGO);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Connection: close\r\n");
        bytes += sprintf((char*)m_pHttpHead + bytes,"Content-Length: %d\r\n\r\n", m_nSendBufLen);
        

        m_nHttpHeadLen = bytes;
        
        return 1;
}

int CHttpModBase::Response200(EM_MIME_TYPE_T emMime,int content_len)
{
        //head
        int code = 200;
        char msg[] = "OK";
        char type[64] = "";
        
        if (emMime == MIME_M3U8)
        {
                sprintf(type,"%s","application/x-mpegURL");
        }
        else if (emMime == MIME_TS || emMime == MIME_CHUNK)
        {
                sprintf(type,"%s","video/MP2T");
        }


        int bytes = sprintf((char*)m_pHttpHead,"HTTP/1.1 %d %s\r\n", code, msg);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Server: %s\r\n",SERVER_LOGO);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Content-Type: %s\r\n", type);
        bytes += sprintf((char*)m_pHttpHead + bytes,"Connection: keep-alive\r\n");
        

        if (emMime == MIME_CHUNK)
        {
                bytes += sprintf((char*)m_pHttpHead + bytes,"Transfer-Encoding: chunked\r\n\r\n");
                bytes += sprintf((char*)m_pHttpHead + bytes,"%x\r\n",content_len);
        }
        else
        {
                bytes += sprintf((char*)m_pHttpHead + bytes,"Content-Length: %d\r\n\r\n", content_len);
        }
        m_nHttpHeadLen = bytes;
        
        return 1;
}
