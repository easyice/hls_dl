/*
   <one line to give the program's name and a brief idea of what it does.>
   Copyright (C) 2012  elva <email>

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "ctsreadervod.h"
#include "ctsreadertstv.h"
#include "zapp.h"

#define DEFAULT_END_TIME (360000ll)

CTsReaderTstv::CTsReaderTstv()
{
	m_pTsReaderVod = new CTsReaderVod();
	m_fScale = 1;
}

CTsReaderTstv::~CTsReaderTstv()
{
	delete m_pTsReaderVod;
}

bool CTsReaderTstv::Open(OVT_STRU_CREATE_USER_OBJ_INFO stInfo)
{
	m_stInfo = stInfo;
	return m_pTsReaderVod->Open(stInfo);
}

bool CTsReaderTstv::Open(const std::string& filename,const char* mode)
{
	//do not use
	return true;
}

bool CTsReaderTstv::Close()
{
	return m_pTsReaderVod->Close();
}

bool CTsReaderTstv::Seek(long long llTimeCode)
{
	return m_pTsReaderVod->Seek(llTimeCode);
}

bool CTsReaderTstv::Switch(float fScale)
{
	m_fScale = fScale;
	return m_pTsReaderVod->Switch(fScale);
}

int CTsReaderTstv::ReadGop(BYTE* pBuf, int nBufSize,long long &beginpcrvalue,
		long long &endpcrvalue, long long& llTimeCodePcr)
{
	int iRet = m_pTsReaderVod->ReadGop(pBuf,nBufSize,beginpcrvalue,endpcrvalue,llTimeCodePcr);

	if (iRet != -F_ERR_REACH_END)
	{
		return iRet;
	}

	ZLOG(ZLT_WARNING, "EOF is encountered, will read the next resource", V(iRet));

	//关闭当前片段
	Close();

	//加载下一个
        if (!OpenNextObj())
        {
                return -F_ERR_OPEN_FAILD;
        }
        
        //切换参数
        if (!ChangeToNextTstv())
        {
                return -F_ERR_OPEN_FAILD;
        }
        
        //读取下一个
        return m_pTsReaderVod->ReadGop(pBuf,nBufSize,beginpcrvalue,endpcrvalue,llTimeCodePcr);
}

int CTsReaderTstv::Read(BYTE* pBuf, int nBufSize)
{
	//do not use
	return 0;
}

bool CTsReaderTstv::OpenNextObj()
{
	int iCurAssetSeq = atoi(m_stInfo.strAssetId.substr(12).c_str());

	if (m_fScale > 0)
	{
		if(++iCurAssetSeq >= 100000000) iCurAssetSeq = 0;
	}
	else
	{
		iCurAssetSeq = max(0,iCurAssetSeq - 1);
	}

	string strnext_asset_id(m_stInfo.strAssetId.substr(0,12));
	stringstream ss;
	ss << iCurAssetSeq;
	strnext_asset_id = strnext_asset_id + string(8 - ss.str().size(),'0') + ss.str();

	m_stInfo.strAssetId = strnext_asset_id;
	m_stInfo.llStartPoint = 0;
	m_stInfo.llBeginTime = 0;
	m_stInfo.llEndTime = DEFAULT_END_TIME * 1000;

	m_pTsReaderVod->m_iUserObjId = CreateUserObj(m_stInfo);
	if (m_pTsReaderVod->m_iUserObjId < 0)
	{
		ZLOG(ZLT_ERROR,"CreateUserObj 失败！",V(m_pTsReaderVod->m_iUserObjId),V(m_stInfo.strAssetId));
		return false;
	}

	return true;
}

bool CTsReaderTstv::ChangeToNextTstv()
{
        OVT_STRU_NGOD_USER_OBJ_PROG_INFO struObjProgInfo;
	EN_USER_OBJ_CONTROL_TYPE controltype;
	UNION_CONTROL_PARAMS control_param;
	int iretsetparam = -1;
        int iSleepMs = 20;
        int iRetryCount = 100;
        
        while ((iretsetparam = GetNgodObjInfo(m_pTsReaderVod->m_iUserObjId,struObjProgInfo)) != 0)
        {
                usleep(iSleepMs*1000);
                iRetryCount--;
                
                if (iRetryCount <= 0 || iretsetparam == -1065)//-1605 is read error
                {
                        ZLOG(ZLT_ERROR,"GetNgodObjInfo失败",V(iretsetparam),V(m_pTsReaderVod->m_iUserObjId),V(struObjProgInfo.llEndPcr));
                        return false;
                }
        }
        
	if(m_fScale > 1)
	{
		controltype = EN_USER_OBJ_CONTROL_FAST;
		control_param.fScale = m_fScale;
		ZLOG(ZLT_INFO,"vsfilesource  下一个预快进",V(m_pTsReaderVod->m_iUserObjId),V(m_stInfo.strAssetId),V(m_stInfo.strProviderId),V(m_fScale),V(controltype));
	}
	else if(m_fScale == 1)
	{
		controltype = EN_USER_OBJ_CONTROL_PLAY;
		ZLOG(ZLT_INFO,"vsfilesource 下一个预正常播放",V(m_pTsReaderVod->m_iUserObjId),V(m_stInfo.strAssetId),V(m_stInfo.strProviderId),V(m_fScale),V(controltype));
	}
	else if(m_fScale < 0)
	{
		controltype = EN_USER_OBJ_CONTROL_SEEK;
		control_param.llTimeCode = struObjProgInfo.llEndPcr/27000;
		if ( (iretsetparam = SetNextParams(m_pTsReaderVod->m_iUserObjId, controltype, control_param)) != 0)
                {
                        ZLOG(ZLT_ERROR,"SetNextParams timecode 失败",V(iretsetparam),V(m_pTsReaderVod->m_iUserObjId),V(m_stInfo.strAssetId),V(m_stInfo.strProviderId),V(m_fScale),V(controltype),V(control_param.llTimeCode));
                        return false;
                }
		ZLOG(ZLT_INFO,"vsfilesource 下一个预跳转",V(m_pTsReaderVod->m_iUserObjId),V(m_stInfo.strAssetId),V(m_stInfo.strProviderId),V(m_fScale),V(controltype),V(control_param.llTimeCode));

		controltype =  EN_USER_OBJ_CONTROL_FAST;
		control_param.fScale = m_fScale;
		ZLOG(ZLT_INFO,"vsfilesource 下一个预快退",V(m_pTsReaderVod->m_iUserObjId),V(m_stInfo.strAssetId),V(m_stInfo.strProviderId),V(m_fScale),V(controltype));
	}
	
	iretsetparam = SetNextParams(m_pTsReaderVod->m_iUserObjId, controltype, control_param);
	if(iretsetparam != 0)
	{
		ZLOG(ZLT_ERROR,"vsfilesource 切换片段失败，尝试重新调度index",V(m_pTsReaderVod->m_iUserObjId),V(iretsetparam),V(m_stInfo.strAssetId),V(m_stInfo.strProviderId),
				V(m_fScale),V(m_stInfo.strAssetId));
		return false;
	}
        
        return true;
}


