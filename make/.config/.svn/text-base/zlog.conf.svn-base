<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<ZXML>
    <ZLOG>
        <PROC_PERIOD>1000</PROC_PERIOD>
        <MAX_PROC_COUNT>10000</MAX_PROC_COUNT>
        <ENABLE_LEVEL>0</ENABLE_LEVEL>
        <MAX_FILE_RECODES>200000</MAX_FILE_RECODES>
        <MAX_FILES_COUNT>100</MAX_FILES_COUNT>
        <ENABLE_TEXT>1</ENABLE_TEXT>
        <ENABLE_CONSOLE>1</ENABLE_CONSOLE>
        <ENABLE_DB>0</ENABLE_DB>
        <LOG_LIST>
            <LOG src_info="zthread.cpp:123">
                <LEVEL>2</LEVEL>
                <FUNCTION>static void* ZBaseThread::ZThreadRuntimeFunc(void*)</FUNCTION>
                <MESSAGE>线程启动</MESSAGE>
                <VARS id="0">
                    <NAME>This-&gt;m_ThreadName</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC>线程名称</DESC>
                </VARS>
                <VARS id="1">
                    <NAME>This-&gt;m_tid</NAME>
                    <TYPE>j</TYPE>
                    <DESC />
                </VARS>
                <VARS id="2">
                    <NAME>(unsigned int)This-&gt;m_hThread</NAME>
                    <TYPE>j</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="ccachemgr.cpp:61">
                <LEVEL>7</LEVEL>
                <FUNCTION>int CCacheMgr::Init()</FUNCTION>
                <MESSAGE>shmid</MESSAGE>
                <VARS id="0">
                    <NAME>iShmId</NAME>
                    <TYPE>i</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="crtr.cpp:115">
                <LEVEL>7</LEVEL>
                <FUNCTION>bool Crtr::Init()</FUNCTION>
                <MESSAGE>尝试从共享内存恢复数据</MESSAGE>
            </LOG>
            <LOG src_info="crtr.cpp:76">
                <LEVEL>7</LEVEL>
                <FUNCTION>int Crtr::RecoverFromCache()</FUNCTION>
                <MESSAGE>从共享内存中恢复的数据</MESSAGE>
                <VARS id="0">
                    <NAME>rc_Data.programID</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>rc_Data.AssetId</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
                <VARS id="2">
                    <NAME>rc_Data.ProviderId</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
                <VARS id="3">
                    <NAME>rc_Data.SubType</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
                <VARS id="4">
                    <NAME>rti_id</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="CManCacheManager.cpp:12">
                <LEVEL>1</LEVEL>
                <FUNCTION>CManCacheManager::CManCacheManager(CTaskQueue*, CManCacheShmManager*)</FUNCTION>
                <MESSAGE>CManCacheManage ()begin</MESSAGE>
            </LOG>
            <LOG src_info="zcomm.cpp:181">
                <LEVEL>1</LEVEL>
                <FUNCTION>virtual void ZComm::OnBaseThreadProc()</FUNCTION>
                <MESSAGE>检测ZComm状态。</MESSAGE>
            </LOG>
            <LOG src_info="zgenclientchannel.cpp:41">
                <LEVEL>2</LEVEL>
                <FUNCTION>void ZGenClientChannel::InitClientChannel(ZSockAddr, ZGenClientProcesser*, ZGenMsgQueueBase*, const ZGenProtocol*, WORD, WORD)</FUNCTION>
                <MESSAGE>通用通讯客户端通道初始化：</MESSAGE>
                <VARS id="0">
                    <NAME>(const string &amp;)RemoteAddr</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC>服务器地址</DESC>
                </VARS>
                <VARS id="1">
                    <NAME>GetProtocol()-&gt;GetProtocolName()</NAME>
                    <TYPE>PKc</TYPE>
                    <DESC>使用协议</DESC>
                </VARS>
                <VARS id="2">
                    <NAME>ChannelId</NAME>
                    <TYPE>t</TYPE>
                    <DESC>通道ID</DESC>
                </VARS>
                <VARS id="3">
                    <NAME>MaxStreamCount</NAME>
                    <TYPE>t</TYPE>
                    <DESC>最大流计数</DESC>
                </VARS>
            </LOG>
            <LOG src_info="crtr.cpp:186">
                <LEVEL>7</LEVEL>
                <FUNCTION>bool Crtr::Init()</FUNCTION>
                <MESSAGE>准备恢复任务队列，RTI 信息：</MESSAGE>
                <VARS id="0">
                    <NAME>RecAddress</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cfilemgr.cpp:85">
                <LEVEL>7</LEVEL>
                <FUNCTION>void CFileMgr::Recovery(const RECOVERY_LIST$)</FUNCTION>
                <MESSAGE>恢复任务信息:</MESSAGE>
                <VARS id="0">
                    <NAME>filename</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="zgenchannel.cpp:722">
                <LEVEL>1</LEVEL>
                <FUNCTION>bool ZGenChannel::ChangeChannelStat(GEN_COMM_STAT_T)</FUNCTION>
                <MESSAGE>通道状态成功改变</MESSAGE>
                <VARS id="0">
                    <NAME>ChannelId</NAME>
                    <TYPE>t</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>Stat</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="zgenclientchannel.cpp:557">
                <LEVEL>1</LEVEL>
                <FUNCTION>bool ZGenClientChannel::ConnectToServer()</FUNCTION>
                <MESSAGE>SELECT_WAIT</MESSAGE>
                <VARS id="0">
                    <NAME>Addr</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>sock</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="zgenclientchannel.cpp:578">
                <LEVEL>4</LEVEL>
                <FUNCTION>bool ZGenClientChannel::ConnectToServer()</FUNCTION>
                <MESSAGE>连接到远程服务器错误</MESSAGE>
                <VARS id="0">
                    <NAME>Addr</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>sock</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
                <VARS id="2">
                    <NAME>LASTERROR</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC>最后一次错误信息</DESC>
                </VARS>
            </LOG>
            <LOG src_info="cgetoutdata.cpp:72">
                <LEVEL>1</LEVEL>
                <FUNCTION>static void* CGetOutData::GetOutDataThread(void*)</FUNCTION>
                <MESSAGE>10秒内未收到数据!</MESSAGE>
                <VARS id="0">
                    <NAME>llemptycount</NAME>
                    <TYPE>x</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="1">
                    <NAME>llsecond</NAME>
                    <TYPE>x</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="cfileoptstv.cpp:450">
                <LEVEL>3</LEVEL>
                <FUNCTION>int CFileOpTstv::OnRecvIndexData(BYTE*, int)</FUNCTION>
                <MESSAGE>Index 文件不连续</MESSAGE>
                <VARS id="0">
                    <NAME>(char*)pUdpHead-&gt;AssetID</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cfilemgr.cpp:157">
                <LEVEL>7</LEVEL>
                <FUNCTION>void CFileMgr::OnRecvData(unsigned char*, int)</FUNCTION>
                <MESSAGE>文件传输完毕，释放文件资源</MESSAGE>
                <VARS id="0">
                    <NAME>filename</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="crtr.cpp:96">
                <LEVEL>7</LEVEL>
                <FUNCTION>int Crtr::RecoverFromCache()</FUNCTION>
                <MESSAGE>共享内存中没有需要恢复的数据</MESSAGE>
            </LOG>
            <LOG src_info="cfilemgr.cpp:199">
                <LEVEL>7</LEVEL>
                <FUNCTION>void CFileMgr::OnRecvData(unsigned char*, int)</FUNCTION>
                <MESSAGE>打开文件成功</MESSAGE>
                <VARS id="0">
                    <NAME>filename</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>fileop.FileOp</NAME>
                    <TYPE>P11CFileOpBase</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cfileoptstv.cpp:474">
                <LEVEL>4</LEVEL>
                <FUNCTION>int CFileOpTstv::OnRecvIndexData(BYTE*, int)</FUNCTION>
                <MESSAGE>写入位置不连续：理论值及实际值</MESSAGE>
                <VARS id="0">
                    <NAME>(char*)pUdpHead-&gt;ProviderID</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>(char*)pUdpHead-&gt;Subtype</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC />
                </VARS>
                <VARS id="2">
                    <NAME>m_ullNextOffset</NAME>
                    <TYPE>y</TYPE>
                    <DESC />
                </VARS>
                <VARS id="3">
                    <NAME>ullfilepos</NAME>
                    <TYPE>y</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cfileoptstv.cpp:493">
                <LEVEL>7</LEVEL>
                <FUNCTION>int CFileOpTstv::OnRecvIndexData(BYTE*, int)</FUNCTION>
                <MESSAGE>刷index头</MESSAGE>
                <VARS id="0">
                    <NAME>pCacheUnit.GetUsedCacheSize()</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cfileoptstv.cpp:218">
                <LEVEL>3</LEVEL>
                <FUNCTION>int CFileOpTstv::OnRecvFFData(BYTE*, int)</FUNCTION>
                <MESSAGE>FF: 字节对齐中</MESSAGE>
                <VARS id="0">
                    <NAME>ullfilepos</NAME>
                    <TYPE>y</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cfileoptstv.cpp:355">
                <LEVEL>3</LEVEL>
                <FUNCTION>int CFileOpTstv::OnRecvFRData(BYTE*, int)</FUNCTION>
                <MESSAGE>FR: 字节对齐中</MESSAGE>
                <VARS id="0">
                    <NAME>ullfilepos + ipayloadsize</NAME>
                    <TYPE>y</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cfileopbase.cpp:32">
                <LEVEL>7</LEVEL>
                <FUNCTION>CFileOpBase::CFileOpBase(int, BYTE*)</FUNCTION>
                <MESSAGE>只缓存，不写文件</MESSAGE>
            </LOG>
            <LOG src_info="zthread.cpp:115">
                <LEVEL>2</LEVEL>
                <FUNCTION>static void* ZBaseThread::ZThreadRuntimeFunc(void*)</FUNCTION>
                <MESSAGE>线程启动</MESSAGE>
                <VARS id="0">
                    <NAME>This-&gt;m_ThreadName</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC>线程名称</DESC>
                </VARS>
                <VARS id="1">
                    <NAME>This-&gt;m_tid</NAME>
                    <TYPE>j</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="2">
                    <NAME>(unsigned int)This-&gt;m_hThread</NAME>
                    <TYPE>j</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="crtr.cpp:118">
                <LEVEL>7</LEVEL>
                <FUNCTION>bool Crtr::Init()</FUNCTION>
                <MESSAGE>尝试从共享内存恢复数据</MESSAGE>
            </LOG>
            <LOG src_info="crtr.cpp:99">
                <LEVEL>7</LEVEL>
                <FUNCTION>int Crtr::RecoverFromCache()</FUNCTION>
                <MESSAGE>共享内存中没有需要恢复的数据</MESSAGE>
            </LOG>
            <LOG src_info="repeatsend.cpp:52">
                <LEVEL>7</LEVEL>
                <FUNCTION>bool RepeatSend::InitRepeatSend()</FUNCTION>
                <MESSAGE>InitRepeatSend</MESSAGE>
                <VARS id="0">
                    <NAME>m_strip</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="1">
                    <NAME>m_nSendPort</NAME>
                    <TYPE>i</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="2">
                    <NAME>m_sock</NAME>
                    <TYPE>i</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="cprogrammgr.cpp:161">
                <LEVEL>7</LEVEL>
                <FUNCTION>void CProgramMgr::OnRecvData(unsigned char*, int)</FUNCTION>
                <MESSAGE>收到新节目</MESSAGE>
                <VARS id="0">
                    <NAME>program_id</NAME>
                    <TYPE>i</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="cprogramprocess.cpp:253">
                <LEVEL>7</LEVEL>
                <FUNCTION>void CProgramProcess::ProcessFun(BYTE*)</FUNCTION>
                <MESSAGE>打开文件成功</MESSAGE>
                <VARS id="0">
                    <NAME>filename</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="cfilecache.cpp:413">
                <LEVEL>7</LEVEL>
                <FUNCTION>int CFileCache::WriteCacheIDX(const PROCESS_DATA_T$)</FUNCTION>
                <MESSAGE>跨块：</MESSAGE>
                <VARS id="0">
                    <NAME>iFreeSize</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>stInfo.nLen</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
                <VARS id="2">
                    <NAME>pCacheUnit.GetStartOffset()</NAME>
                    <TYPE>x</TYPE>
                    <DESC />
                </VARS>
                <VARS id="3">
                    <NAME>stInfo.llOffset</NAME>
                    <TYPE>x</TYPE>
                    <DESC />
                </VARS>
                <VARS id="4">
                    <NAME>stInfo.llOffset</NAME>
                    <TYPE>x</TYPE>
                    <DESC />
                </VARS>
                <VARS id="5">
                    <NAME>pCacheUnit.GetStartPos()</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
                <VARS id="6">
                    <NAME>pCacheUnit.GetEndPos()</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cfilecache.cpp:351">
                <LEVEL>7</LEVEL>
                <FUNCTION>int CFileCache::WriteCacheIDX(const PROCESS_DATA_T$)</FUNCTION>
                <MESSAGE>刷index头</MESSAGE>
                <VARS id="0">
                    <NAME>pCacheUnit.GetUsedCacheSize()</NAME>
                    <TYPE>i</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="cprogramprocess.cpp:216">
                <LEVEL>7</LEVEL>
                <FUNCTION>void CProgramProcess::ProcessFun(BYTE*)</FUNCTION>
                <MESSAGE>文件传输完毕，释放文件资源</MESSAGE>
                <VARS id="0">
                    <NAME>filename</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="crtr.cpp:79">
                <LEVEL>7</LEVEL>
                <FUNCTION>int Crtr::RecoverFromCache()</FUNCTION>
                <MESSAGE>从共享内存中恢复的数据</MESSAGE>
                <VARS id="0">
                    <NAME>rc_Data.programID</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>rc_Data.AssetId</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
                <VARS id="2">
                    <NAME>rc_Data.ProviderId</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
                <VARS id="3">
                    <NAME>rc_Data.SubType</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
                <VARS id="4">
                    <NAME>rti_id</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
                <VARS id="5">
                    <NAME>i</NAME>
                    <TYPE>x</TYPE>
                    <DESC />
                </VARS>
                <VARS id="6">
                    <NAME>pCache + i</NAME>
                    <TYPE>Ph</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="crtr.cpp:196">
                <LEVEL>7</LEVEL>
                <FUNCTION>bool Crtr::Init()</FUNCTION>
                <MESSAGE>准备恢复任务队列，RTI 信息：</MESSAGE>
                <VARS id="0">
                    <NAME>RecAddress</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cprogramprocess.cpp:148">
                <LEVEL>7</LEVEL>
                <FUNCTION>void CProgramProcess::Recovery(const RECOVERY_DATA$)</FUNCTION>
                <MESSAGE>恢复任务信息:</MESSAGE>
                <VARS id="0">
                    <NAME>filename</NAME>
                    <TYPE>Ss</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="repeatsend.cpp:142">
                <LEVEL>3</LEVEL>
                <FUNCTION>int RepeatSend::InsertNewRepeatSend(long long int, long long int)</FUNCTION>
                <MESSAGE>请求重传</MESSAGE>
                <VARS id="0">
                    <NAME>BeginNumber</NAME>
                    <TYPE>x</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>EndNumber</NAME>
                    <TYPE>x</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cbufferprocess.cpp:208">
                <LEVEL>7</LEVEL>
                <FUNCTION>bool CBufferProcess::GetNextData(int, std::vector{unsigned char*, std::allocator{unsigned char*} }$)</FUNCTION>
                <MESSAGE>缓冲剩余空间小于2000,当前缓冲状态：</MESSAGE>
                <VARS id="0">
                    <NAME>m_nextoutdatanumber</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>m_nextrecvnumber</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
                <VARS id="2">
                    <NAME>freebuffercount</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cprogramprocess.cpp:76">
                <LEVEL>4</LEVEL>
                <FUNCTION>int CProgramProcess::AddData(BYTE*, int)</FUNCTION>
                <MESSAGE>缓存已满，处理线程运作缓慢</MESSAGE>
            </LOG>
            <LOG src_info="cfileopbase.cpp:126">
                <LEVEL>4</LEVEL>
                <FUNCTION>int CFileOpBase::OnRecvData(BYTE*, int)</FUNCTION>
                <MESSAGE>数据包序列号不连续：理论值及实际值</MESSAGE>
                <VARS id="0">
                    <NAME>(char*)pUdpHead-&gt;ProviderID</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="1">
                    <NAME>(char*)pUdpHead-&gt;Subtype</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="2">
                    <NAME>m_ullNextPacketNumber</NAME>
                    <TYPE>y</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="3">
                    <NAME>ullfilepacketindex</NAME>
                    <TYPE>y</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="cfileopbase.cpp:157">
                <LEVEL>4</LEVEL>
                <FUNCTION>int CFileOpBase::OnRecvData(BYTE*, int)</FUNCTION>
                <MESSAGE>写入位置不连续：理论值及实际值</MESSAGE>
                <VARS id="0">
                    <NAME>(char*)pUdpHead-&gt;ProviderID</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC />
                </VARS>
                <VARS id="1">
                    <NAME>(char*)pUdpHead-&gt;Subtype</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC />
                </VARS>
                <VARS id="2">
                    <NAME>m_ullNextOffset</NAME>
                    <TYPE>y</TYPE>
                    <DESC />
                </VARS>
                <VARS id="3">
                    <NAME>ullfilepos</NAME>
                    <TYPE>y</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cfileopbase.cpp:146">
                <LEVEL>4</LEVEL>
                <FUNCTION>int CFileOpBase::OnRecvData(BYTE*, int)</FUNCTION>
                <MESSAGE>写入位置不连续：理论值及实际值</MESSAGE>
                <VARS id="0">
                    <NAME>(char*)pUdpHead-&gt;ProviderID</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="1">
                    <NAME>(char*)pUdpHead-&gt;Subtype</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="2">
                    <NAME>m_ullNextOffset</NAME>
                    <TYPE>y</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="3">
                    <NAME>ullfilepos</NAME>
                    <TYPE>y</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="cfileopbase.cpp:136">
                <LEVEL>4</LEVEL>
                <FUNCTION>int CFileOpBase::OnRecvData(BYTE*, int)</FUNCTION>
                <MESSAGE>写入位置不连续：理论值及实际值</MESSAGE>
                <VARS id="0">
                    <NAME>(char*)pUdpHead-&gt;ProviderID</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="1">
                    <NAME>(char*)pUdpHead-&gt;Subtype</NAME>
                    <TYPE>Pc</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="2">
                    <NAME>m_ullLastOffset-ipayloadsize</NAME>
                    <TYPE>y</TYPE>
                    <DESC></DESC>
                </VARS>
                <VARS id="3">
                    <NAME>ullfilepos</NAME>
                    <TYPE>y</TYPE>
                    <DESC></DESC>
                </VARS>
            </LOG>
            <LOG src_info="cprogramprocess.cpp:89">
                <LEVEL>7</LEVEL>
                <FUNCTION>void CProgramProcess::Destroy()</FUNCTION>
                <MESSAGE>等待线程退出</MESSAGE>
                <VARS id="0">
                    <NAME>tid</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cprogramprocess.cpp:91">
                <LEVEL>7</LEVEL>
                <FUNCTION>void CProgramProcess::Destroy()</FUNCTION>
                <MESSAGE>线程已退出</MESSAGE>
                <VARS id="0">
                    <NAME>tid</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="cprogrammgr.cpp:107">
                <LEVEL>3</LEVEL>
                <FUNCTION>static void* CProgramMgr::CheckTimeOutThread(void*)</FUNCTION>
                <MESSAGE>删除超时的任务,此任务可能由于网络原因未完成传输</MESSAGE>
                <VARS id="0">
                    <NAME>program_id</NAME>
                    <TYPE>i</TYPE>
                    <DESC />
                </VARS>
            </LOG>
            <LOG src_info="ccacheunit.cpp:204">
                <LEVEL>7</LEVEL>
                <FUNCTION>void CCacheUnit::WritePayload(long long unsigned int, int, BYTE*)</FUNCTION>
                <MESSAGE>writepos:</MESSAGE>
                <VARS id="0">
                    <NAME>iwritepos</NAME>
                    <TYPE>x</TYPE>
                    <DESC />
                </VARS>
            </LOG>
        </LOG_LIST>
    </ZLOG>
    <HELP>
        <ZLOG>
            <PROC_PERIOD>LOG处理周期时间，单位：1/1000秒</PROC_PERIOD>
            <MAX_PROC_COUNT>在每个处理周期内允许最大的LOG数量，将申请此数量二倍的LOG缓冲区处理LOG，不能实时生效，必须重新启动</MAX_PROC_COUNT>
            <ENABLE_LEVEL>允许LOG记录的级别：0-全部，1-INFO，2－NOTIFY,3-WARNING,4-ERROR,5-FAULT,6-USER</ENABLE_LEVEL>
            <MAX_FILE_RECODES>每一个LOG文件最大允许的记录数量，超出时将被分割为多个文件</MAX_FILE_RECODES>
            <MAX_FILES_COUNT>系统中最大支持多少个LOG文件，多余的将被删除，以免超出磁盘有效空间</MAX_FILES_COUNT>
            <ENABLE_TEXT>是否允许文本方式记录LOG信息</ENABLE_TEXT>
            <ENABLE_CONSOLE>是否允许控制台方式输出LOG信息</ENABLE_CONSOLE>
            <ENABLE_DB>是否允许数据库方式记录LOG信息</ENABLE_DB>
            <LOG_LIST>
                <LOG>
                    <LEVEL>此LOG等级</LEVEL>
                    <FUNCTION>此LOG的函数</FUNCTION>
                    <MESSAGE>此LOG所携带的信息</MESSAGE>
                    <VARS>
                        <NAME>LOG变量名</NAME>
                        <TYPE>变量的类型</TYPE>
                        <DESC>变量描述</DESC>
                    </VARS>
                </LOG>
            </LOG_LIST>
        </ZLOG>
    </HELP>
</ZXML>
